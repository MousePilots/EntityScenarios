package org.mousepilots.es.maven.model.generator.plugin;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.sql.Blob;
import java.util.Collection;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;

import javax.persistence.metamodel.StaticMetamodel;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.reflections.Reflections;

/**
 * Generates an extended static meta-model for a JPA-classes. The recommended approach is to create a separate Maven module for generating extended static meta-model classes, e.g.
 * <strong>domain-mmx</strong> dependent on your <strong>domain</strong> module. This prevents circular dependencies and provides seperation of concerns. For this to work, the following conditions
 * must be met:
 * <ol>
 * <li>your JPA domain classes must be packaged with:
 * <ol>
 * <li>the JPA static meta-model classes generated by the persistence-provider of your choosing</li>
 * <li>the <a href="https://github.com/ronmamo/reflections">reflections</a> xml descriptor, containing an analysis of your JPA domain classes and JPA static meta model classes</li>
 * </ol>
 * </li>
 * <li>your JPA domain-model classes, their JPA static meta-model classes and all of their transitive dependencies must be on the plugin's classpath. This includes your JPA provider. Note:
 * dependencies are added to the {@code <dependencies>} section of the plugin: NOT the domain-mmx module's dependencies!</li>
 * <li>In order for your domain and domain-mmx classes to be usable in GWT, you must package their sources and configure appropriate GWT modules to be extended in your web app's GWT module(s)</li>
 * </ol>
 * The purpose of this mojo is twofold:
 * <ol>
 * <li>Analyze your JPA classes' static meta model</li>
 * <li>Generate GWT-executable extended meta model classes</li>
 * </ol>
 * This mojo generates as little code as possible. This is achieved by having generated classes extend some abstract base class which implements an interface intended for use by developers. The
 * abstract base classes implement as much state and logic as possible. Code is generated using velocity templates and corresponding descriptors. A descriptor’s relation to a template is similar to a
 * backing bean’s relation to a JSF page. The strategy is not to write descriptors to disk until all descriptors are generated in memory. This allows the descriptors to refer lazily to one another in
 * memory. Finally, the plugin also generates {@link ValueWrapper}s for attribute The relation between a generated class file, interface, abstract base class, velocity templates and discriptor is
 * shown below for the most important types of generated classes.
 * <table style="border:1px solid black">
 * <tr>
 * <th>Generated file</th>
 * <th>Interface</th>
 * <th>Abstract base</th>
 * <th>Velocity template</th>
 * <th>Descriptor</th>
 * </tr>
 * <tr>
 * <td>{@code MetaModelImpl}</td>
 * <td>{@link MetaModel}</td>
 * <td>{@link AbstractMetaModel}</td>
 * <td>{@code AbstractMetaModelImpl.vsl}</td>
 * <td>n.a.</td>
 * </tr>
 * <tr>
 * <td>{@code MyDomainClass__}</td>
 * <td>{@link Type}</td>
 * <td>{@link AbstractType}</td>
 * <td>{@code AbstractTypeImpl.vsl}</td>
 * <td>{@link TypeDescriptor}</td>
 * </tr>
 * <tr>
 * <td>{@code MyDomainClass__myAttribute}</td>
 * <td>{@link Attribute}</td>
 * <td>{@link AbstractAttribute}</td>
 * <td>{@code AbstractAttributeImpl.vsl}</td>
 * <td>{@link AttributeDescriptor}</td>
 * </tr>
 * <tr>
 * <td>{@code MyAttributeTypeWrapper}</td>
 * <td>{@link ValueWrapper}</td>
 * <td>{@link ValueWrapperImpl}</td>
 * <td>{@code ValueWrapperImpl.vsl}</td>
 * <td>{@link SingularAttributeValueWrapperDescriptor} or {@link PluralAttributeValueWrapperDescriptor}</td>
 * </tr>
 * </table>
 * 
 * @author Jurjen van Geenen
 */
@Mojo(name = "generate", requiresDependencyCollection = ResolutionScope.COMPILE_PLUS_RUNTIME, requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME, defaultPhase = LifecyclePhase.GENERATE_SOURCES, executionStrategy = "once-per-session"

)
public class MetaModelGeneratorMojo extends AbstractMojo
{
  /**
   * used to prevent multiple executions within the same maven session
   */ 
  private static boolean executed = false;

   /**
    * Enumerates the sub-packages of {@link #packageName}
    */
   private enum SubPackage
   {

      /**
       * The subpackage in which the {@link MetaModel} implementation is written
       */
      META_MODEL(""),
      /**
       * The subpackage in which {@link Type} implementations are written
       */
      TYPE("type"),

      /**
       * The subpackage in which {@link DTO_Facade} implementations are written
       */
      DTO_FACADE("dto.facade"),
      /**
       * The subpackage in which {@link Attribute} implementations are written
       */
      ATTRIBUTE("attribute");

      private SubPackage(String subPackage)
      {
         this.name = subPackage;
      }

      private final String name;

      /**
       * @return the name of the subpackage, relative to {@link MetaModelGeneratorMojo#packageName}
       */
      public String getSubPackageName()
      {
         return name;
      }
   }

   /**
    * @param subPackage
    * @return the fully qualified package name of the {@code subPackage}, resolved against {@link #packageName}
    */
   private String getPackageName(SubPackage subPackage)
   {
      return subPackage.getSubPackageName().isEmpty() ? this.packageName : this.packageName + "." + subPackage.getSubPackageName();
   }

   /**
    * The fully qualified name of the package in which sources are generated by the plugin. E.g. {@code org.my.package}. The plugin must have this and all of its subpackes to itself
    */
   @Parameter(required = true)
   private String packageName;

   @Parameter(defaultValue = "${project}", readonly = true)
   private MavenProject project;

   /**
    * The fully qualified names of the managed classes you whish to include. Put {@code null} for all.
    */
   @Parameter
   private List<String> includedTypeJavaClasses;

   /**
    * The fully qualified names of attribute classes for which you do not want to generate an attribute. These could e.g. be {@link Blob}s.
    */
   @Parameter
   private List<String> excludedAttributeJavaClasses;

   /**
    * The project folder in which generated sources are put. The plugin should have this and all subfolders to itself.
    */
   @Parameter(defaultValue = "${project.build.directory}/generated-sources/mmx")
   private File generatedSourceDir;

   /**
    * Contains an in-memory representation of the reflections xml report of the domain project
    */
   private Reflections reflections;

   /**
    * The velocity engine for generating source files
    */
   private final VelocityEngine velocityEngine;

   public MetaModelGeneratorMojo()
   {
      super();
      velocityEngine = new VelocityEngine();
      Properties props = new Properties();
      props.put("resource.loader", "class");
      props.put("class.resource.loader.class", "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
      props.put("directive.set.null.allowed", Boolean.TRUE.toString());
      velocityEngine.init(props);
   }

   @Override
   public void execute() throws MojoExecutionException, MojoFailureException
   {
       System.out.println("Hello World from Plugin!");
   }
}